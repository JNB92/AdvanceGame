Advance Game Bot Report

This report is for the software program I have created for a game called “Advance”. Advance is a chess-like board game; however, the pieces have slightly different moves and abilities, giving it a unique twist compared to traditional chess. This program uses object-oriented programming principles, such as inheritance and polymorphism, to create a game bot that can make strategic moves within the game when provided with a valid board represented as text in a text (txt) file.

The program accepts either one or three command-line arguments. If provided the single argument "name", the program will simply print the name of the Bot (Chess bot from Wish) and then ends the program. If provided the arguments “Colour”, which can be either white or black, “input path”, which should be the file path for the board state the player would like to play on, and “output path”, which should be the file path of the location the player would like the result written to. The Advance bot will read the state of the game from the given text file, make a single move as the player of the selected colour, and then output the new board state to the output filepath.

The design of the program is centred around 13 classes: Zombie, Builder, Jester, Sentinel, Catapult, Dragon, Miner, General, Wall, Program, Piece Factory, Piece, and Board. These classes work together to simulate a game, evaluate board states, determine legal moves, and print the results to a text file once complete.

The classes Zombie, Builder, Jester, Sentinel, Catapult, Dragon, Miner, General, and Wall represent the game's pieces. They inherit from the abstract Piece class, allowing them to use the GetValidMoves and IsValidMove methods provided by the Piece class. Each piece class is responsible for defining its own movement patterns, but they leverage the inherited methods from the Piece class to consistently determine valid or 'legal' moves in the current board state. The IsValidMove method checks if a particular move is permissible based on the rules of the game, and the GetValidMoves method returns a list of such valid moves. This showcases the use of inheritance and polymorphism in the design, which allows for the creation of piece-specific behavior while maintaining a common interface for interaction.

The PieceFactory class serves to generate the pieces used in the game. It uses the Factory design pattern to encapsulate the process of creating different kinds of Piece objects. This not only separates the responsibility of creating pieces from the main Board class but also provides a way to add more piece types in the future with minimal changes to the existing codebase.

The Board class contains the bulk of the logic needed for the game. It has methods to evaluate the state of the board and determine the best move based on the current situation. Specifically, the MakeMove method decides the move to make by assessing if the General (the key piece) is in danger and then evaluating the best course of action based on a hierarchy of moves outlined in the function.

This starts with checking for moves that capture the threatening piece to remove the danger, then if that isn’t possible, the best protection is checked, this refers to the protection offered by a Sentinel piece. If there is no Sentinel available to provide protection, the next check is which looks to see if a Builder is able to build a wall to remove the General from danger. If all of these checks return with no valid move that will successfully remove the general from danger, it then checks if the General has and valid “safe moves” that it can make that will remove it from immediate danger.

If the General is not in danger, the program goes through a similar series of steps to determine the best move to make. It first tries to capture an enemy piece if possible, as this would result in a material gain. This is then followed by looking for the best non-capture move, which includes checking if the Jester’s “conversion move” is possible, as well as simply the safest move a piece can make without putting itself in any danger. The final move considered is a 'dangerous' move. A 'dangerous' move refers to a move that, while potentially exposing the piece to capture in the next turn, could also lead to a favourable outcome.

Exception handling has been added to areas such as the read and write file methods in the event that there is an issue with reading or writing a file provided through the command-line arguments. This is to ensure that if any errors occur, the program is able to provide the user with a helpful message as to why the error occurred and then gracefully exits the program.

The goal of the design was to keep methods short and maintainable to facilitate readability and future updates. To achieve this, I aimed to incorporate inheritance and polymorphism where I could to ensure that where possible, code was not repeated unnecessarily, and that the principles of object-oriented design were displayed and used correctly.

In the future, I would like to complete the ability to always make the winning move if available and then work to integrate a Minimaxalgorithm to enhance the bot's decision-making capabilities and to make it more complete and competitive in the game.

